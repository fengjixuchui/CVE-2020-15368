#include <wdm.h>

// custom process list shit

#include "dbg_log.h"
#include "MyProcessList.h"

EX_SPIN_LOCK MyProcessInfoListLock;
LIST_ENTRY MyProcessInfoList;

// You need to hold the lock to call this
MyProcessInfo* LookupMyProcessInfo(PEPROCESS Process)
{
    for (LIST_ENTRY* MyListEntry = MyProcessInfoList.Flink; MyListEntry != &MyProcessInfoList; MyListEntry = MyListEntry->Flink)
    {
        MyProcessInfo* myShit = CONTAINING_RECORD(MyListEntry, MyProcessInfo, ListEntry);
        if (myShit->Process == Process)
            return myShit;
    }
    return NULL;
}

PEPROCESS LookupCreatingProcess(PEPROCESS Process)
{
    KIRQL OriginalIrql = ExAcquireSpinLockExclusive(&MyProcessInfoListLock);
    MyProcessInfo* myShit = LookupMyProcessInfo(Process);
    PEPROCESS CreatingProcess = myShit ? myShit->CreatingProcess : NULL;
    ExReleaseSpinLockExclusive(&MyProcessInfoListLock, OriginalIrql);
    return CreatingProcess;
}

BOOLEAN MyProcessInfoAllowOnce(PEPROCESS Process)
{
    KIRQL OriginalIrql = ExAcquireSpinLockExclusive(&MyProcessInfoListLock);
    MyProcessInfo* myShit = LookupMyProcessInfo(Process);
    BOOLEAN Result = FALSE;
    if (myShit)
    {
        Result = myShit->InitialGraceExpired < 6; // allow first 6 handles
        myShit->InitialGraceExpired++;
    }
    ExReleaseSpinLockExclusive(&MyProcessInfoListLock, OriginalIrql);
    return Result;
}

// You need to hold the lock to call this
void FreeMyProcessInfo(MyProcessInfo* myProcessInfo)
{
    RemoveEntryList(&myProcessInfo->ListEntry);
    ObDereferenceObject(myProcessInfo->Process);
    ObDereferenceObject(myProcessInfo->CreatingProcess);
    ExFreePool(myProcessInfo);
}

// You need to hold the lock to call this
MyProcessInfo* CreateMyProcessInfo(PEPROCESS Process, PEPROCESS CreatingProcess)
{
    MyProcessInfo* myShit = ExAllocatePool(NonPagedPool, sizeof(MyProcessInfo));
    if (!myShit)
    {
        DBG_LOG("wtf ExAllocatePool fails");
        __debugbreak();
    }
    RtlZeroMemory(myShit, sizeof(MyProcessInfo));
    DBG_LOG("Process=%p, CreatingProcess=%p", Process, CreatingProcess);
    ObReferenceObject(Process);
    ObReferenceObject(CreatingProcess);
    myShit->Process = Process;
    myShit->CreatingProcess = CreatingProcess;
    myShit->InitialGraceExpired = FALSE;
    InsertHeadList(&MyProcessInfoList, &myShit->ListEntry);
    return myShit;
}

void InitializeMyProcessInfoList()
{
    RtlZeroMemory(&MyProcessInfoListLock, sizeof(MyProcessInfoListLock));
    InitializeListHead(&MyProcessInfoList);
}

void FreeMyProcessInfoList()
{
    KIRQL OriginalIrql = ExAcquireSpinLockExclusive(&MyProcessInfoListLock);
    while (!IsListEmpty(&MyProcessInfoList))
    {
        FreeMyProcessInfo(CONTAINING_RECORD(MyProcessInfoList.Flink, MyProcessInfo, ListEntry));
    }
    ExReleaseSpinLockExclusive(&MyProcessInfoListLock, OriginalIrql);
}