#include <intrin.h>
#include <ntifs.h>
#include <Ntddk.h>
#include <wdm.h>

// important definitions
#include <chonst.h>

#include "proto.h"
#include "NtoskrnlReversedLol.h"
#include "UnstableOffsets.h"

#include "dbg_log.h"
#include "MyProcessList.h"

void* MyRegistrationHandle;
void* MyRegistrationContext;

UCHAR Trampoline[] = {
    0x48, 0xB8, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // mov rax, imm64
    0xff, 0xe0 // jmp rax
};

volatile LONG IsUnloading = 0;
volatile LONG IAmBusyPleaseDoNotUnloadYet = 0; // Refcount to myself :lmao3d:
volatile LONG HaveWorkToDo = 0;

PVOID MyCreateProcessNotifyRoutine_Handle = 0;

KDPC myDpc;
KTIMER myTimer;

PDRIVER_OBJECT pNullDriverObj;
PVOID nullDrvSectionHandle;

#define PROTECTED_PROCESS_NAME "csgo.exe"

void MyCreateProcessNotifyRoutine(
    PEPROCESS Process,
    HANDLE ProcessId,
    PPS_CREATE_NOTIFY_INFO CreateInfo
)
{
    InterlockedIncrement(&IAmBusyPleaseDoNotUnloadYet);

    if (!CreateInfo)
    {
        DBG_LOG("Process exiting: %p %d (%s)", Process, ProcessId, PsGetProcessImageFileName(Process));

        KIRQL OriginalIrql = ExAcquireSpinLockExclusive(&MyProcessInfoListLock);
        MyProcessInfo* myProcessInfo = LookupMyProcessInfo(Process);
        if (myProcessInfo)
        {
            FreeMyProcessInfo(myProcessInfo);
        }
        else
        {
            DBG_LOG("WTF No process info for exiting process??? %p %d (%s)", Process, ProcessId, PsGetProcessImageFileName(Process));
        }
        ExReleaseSpinLockExclusive(&MyProcessInfoListLock, OriginalIrql);
    }
    else
    {
        DBG_LOG("Process created: %p %d (%s)", Process, ProcessId, PsGetProcessImageFileName(Process));
        HANDLE CreatingProcessId = CreateInfo->CreatingThreadId.UniqueProcess;
        PEPROCESS CreatingProcess;
        DBG_LOG("  Created by: pid %p", CreatingProcessId);
        NTSTATUS Result = PsLookupProcessByProcessId(CreatingProcessId, &CreatingProcess);
        if (Result == STATUS_SUCCESS)
        {
            DBG_LOG("  Created by: %s, pid %p", PsGetProcessImageFileName(CreatingProcess), CreatingProcessId);

            KIRQL OriginalIrql = ExAcquireSpinLockExclusive(&MyProcessInfoListLock);
            CreateMyProcessInfo(Process, CreatingProcess);
            ExReleaseSpinLockExclusive(&MyProcessInfoListLock, OriginalIrql);

            ObDereferenceObject(CreatingProcess); 
        }
        else
        {
            DBG_LOG("PsLookupProcessByProcessId fails?? ntstatus=%x", Result);
        }
        
    }

    InterlockedDecrement(&IAmBusyPleaseDoNotUnloadYet);
}


NTSTATUS MyUnloadRoutine(void* my_start_info)
{
    DBG_LOG("My unload thread runs.");

    // This is fucking stupid. let's just wait 10ms so that the object callbacks have time to return! -.-
    // We can't call ObUnRegisterCallbacks before that, or else shit will hang.
    // Of course, this is a bug since in the meantime another object callback may have started.
    // So every time you unload, you're playing russian roulette! :)
    LARGE_INTEGER interval;
    interval.QuadPart = -10000 * 10;
    KeDelayExecutionThread(KernelMode, FALSE, &interval);

    DBG_LOG("Now we call ObUnRegisterCallbacks.");
    ObUnRegisterCallbacks(MyRegistrationHandle);
    InterlockedDecrement(&IAmBusyPleaseDoNotUnloadYet);

    DBG_LOG("Now we remove PsSetCreateProcessNotifyRoutineEx callback.");
    PsSetCreateProcessNotifyRoutineEx(MyCreateProcessNotifyRoutine_Handle, TRUE);
    InterlockedDecrement(&IAmBusyPleaseDoNotUnloadYet);

    // Wait for all the callbacks and threads to finish
    while (IAmBusyPleaseDoNotUnloadYet) YieldProcessor();

    DBG_LOG("Now we free all of the MyProcessInfo list entries.");
    FreeMyProcessInfoList();

    DBG_LOG("OK now we cancel all timers.");
    KeCancelTimer(&myTimer);

    DBG_LOG("Release reference on Null device.");
    ObDereferenceObject(pNullDriverObj);

    // remove patch in Null device
    // jk im too lazy

    DBG_LOG("Unlock Null device pages.");
    MmUnlockPagableImageSection(nullDrvSectionHandle);

    DBG_LOG("OK MyUnloadRoutine completes.");
    return STATUS_SUCCESS;
}

BOOLEAN IsProcessNameWhitelisted(LPCSTR name)
{
    if (strstr(name, "cheatengine")
        || strstr(name, "BigInjector")
        || strstr(name, "ProcessHac")
        || strstr(name, "x32dbg")
        || strstr(name, "MsMpEng") // LMAO.
        )
        return TRUE;
    return FALSE;
}

BOOLEAN MyEnumHandleProcedure(
    _HANDLE_TABLE* HandleTable,
    PHANDLE_TABLE_ENTRY HandleTableEntry,
    HANDLE Handle,
    PVOID EnumParameter)
{
    PEPROCESS OwningProcess = EnumParameter;

    void* Object = HandleTableEntryToObjectPtr(HandleTableEntry->ObjectPtr);

    //DBG_LOG("Handle %p HandleTableEntry=%p %p Access %x", Handle, HandleTableEntry, Object, HandleTableEntry->GrantedAccess);
    if (!MmIsAddressValid(Object))
        goto exit_func;
    void* ObjectType = ObGetObjectType(Object);
    //DBG_LOG("ObjectType %p", ObjectType);
    if (!MmIsAddressValid(ObjectType))
        goto exit_func;
    UCHAR ObjectTypeIndex = *(UCHAR*)((uintptr_t)ObjectType + OBJECT_TYPE_Index_Offset);
    //DBG_LOG("ObjectTypeIndex %x", ObjectTypeIndex);

    if (ObjectTypeIndex == OBJECT_TYPE_PROCESS_INDEX)
    {
        PEPROCESS kp = (PEPROCESS)Object; // sizeof(_OBJECT_HEADER)
        //DBG_LOG("KPROCESS = %p", kp);
        if (!strcmp(PsGetProcessImageFileName(kp), PROTECTED_PROCESS_NAME))
        {
            DBG_LOG("Found process %s holding handle to protected process %s", PsGetProcessImageFileName(OwningProcess), PsGetProcessImageFileName(kp));
            DBG_LOG("  Handle: %p HandleTableEntry=%p EPROCESS=%p Access=%x", Handle, HandleTableEntry, Object, HandleTableEntry->GrantedAccess);

            if (IsProcessNameWhitelisted(PsGetProcessImageFileName(OwningProcess)))
                goto exit_func;

            if (HandleTableEntry->GrantedAccess & PROCESS_CREATE_THREAD)
            {
                HandleTableEntry->GrantedAccess &= ~PROCESS_CREATE_THREAD;
                DBG_LOG("  Stripping PROCESS_CREATE_THREAD");
            }
            if (HandleTableEntry->GrantedAccess & PROCESS_DUP_HANDLE)
            {
                HandleTableEntry->GrantedAccess &= ~PROCESS_DUP_HANDLE;
                DBG_LOG("  Stripping PROCESS_DUP_HANDLE");
            }
            if (HandleTableEntry->GrantedAccess & PROCESS_QUERY_INFORMATION)
            {
                HandleTableEntry->GrantedAccess &= ~(PROCESS_QUERY_INFORMATION);
                DBG_LOG("  Stripping PROCESS_QUERY_INFORMATION");
            }
            if (HandleTableEntry->GrantedAccess & PROCESS_QUERY_LIMITED_INFORMATION)
            {
                HandleTableEntry->GrantedAccess &= ~(PROCESS_QUERY_LIMITED_INFORMATION);
                DBG_LOG("  Stripping PROCESS_QUERY_LIMITED_INFORMATION");
            }
            if (HandleTableEntry->GrantedAccess & PROCESS_VM_READ)
            {
                HandleTableEntry->GrantedAccess &= ~(PROCESS_VM_READ);
                DBG_LOG("  Stripping PROCESS_VM_READ");
            }

            if (
                PsGetProcessId(OwningProcess) == 4 // allow System process to hold a handle
                || !strcmp(PsGetProcessImageFileName(OwningProcess), "csrss.exe") // Allow csrss to hold a handle
                )
            {
                DBG_LOG("  This process is whitelisted; OK");
                goto exit_func;
            }

            if (HandleTableEntry->GrantedAccess & PROCESS_VM_OPERATION)
            {
                HandleTableEntry->GrantedAccess &= ~PROCESS_VM_OPERATION;
                DBG_LOG("  Stripping PROCESS_VM_OPERATION");
            }
            if (HandleTableEntry->GrantedAccess & PROCESS_SET_LIMITED_INFORMATION)
            {
                HandleTableEntry->GrantedAccess &= ~(PROCESS_SET_LIMITED_INFORMATION);
                DBG_LOG("  Stripping PROCESS_SET_LIMITED_INFORMATION");
            }
            if (HandleTableEntry->GrantedAccess & PROCESS_SET_INFORMATION)
            {
                HandleTableEntry->GrantedAccess &= ~(PROCESS_SET_INFORMATION);
                DBG_LOG("  Stripping PROCESS_SET_INFORMATION");
            }
            if (HandleTableEntry->GrantedAccess & PROCESS_VM_WRITE)
            {
                HandleTableEntry->GrantedAccess &= ~(PROCESS_VM_WRITE);
                DBG_LOG("  Stripping PROCESS_VM_READ");
            }
        }
    }

exit_func:;
    //DBG_LOG("Calling ExUnlockHandleTableEntry");
    ExUnlockHandleTableEntry(HandleTable, HandleTableEntry);
    //DBG_LOG("Exiting func");
    return FALSE;
}

// This shit needs to run at below DISPATCH_LEVEL. (the object table shit might be paged out)
void DemoteBadHandles(PEPROCESS kp)
{
    void* objectTable = *(void**)((uintptr_t)kp + EPROCESS_ObjectTable_Offset);
    // DBG_LOG("ObjectTable %p", objectTable);
    if (objectTable)
    {
        if (MmIsAddressValid(objectTable))
        {
            HANDLE Handle;
            ExEnumHandleTable(objectTable, MyEnumHandleProcedure, kp, &Handle);
        }
        else
        {
            DBG_LOG("YOOOOOOOOO FUCK off. Why does this process have a bad object table pointer???");
        }
    }
}

// This shit needs to run at below DISPATCH_LEVEL.
void ScanForHandles()
{
    // Documentation on PsGetNextProcess
    // http://xref.codetector.org/repos/nt5src_XPSP1/-/blob/base/ntos/ps/psenum.c#L111:1

    for (PEPROCESS kp = PsGetNextProcess(NULL); kp; kp = PsGetNextProcess(kp))
    {
        //DBG_LOG("kp = %p", kp);
        //DBG_LOG("Hello %s", PsGetProcessImageFileName(kp));
        HANDLE pid = PsGetProcessId(kp);
        //DBG_LOG("pid %d", pid);
        DemoteBadHandles(kp);
        //DBG_LOG("DemoteBadHandles returns.");
    }
    DBG_LOG("Ok loop complete");
}

NTSTATUS StripHandleThread(void* my_start_info)
{
    while (!IsUnloading)
    {
        // Wait until we have something to do
        while (!HaveWorkToDo && !IsUnloading) YieldProcessor();
        if (IsUnloading)
            break;

        ScanForHandles();

        InterlockedDecrement(&HaveWorkToDo);
    }

    DBG_LOG("Handle stripping thread completes");

    InterlockedDecrement(&IAmBusyPleaseDoNotUnloadYet); // was incremented when we started the thread

    return STATUS_SUCCESS;
}

void UnloadDriver()
{
    // Don't unload multiple times
    if (InterlockedCompareExchange(&IsUnloading, 1, 0) != 0)
    {
        DBG_LOG("Unload already requested.");
        return;
    }

    DBG_LOG("Okay we unload!.");

    HANDLE hThread;
    PsCreateSystemThread(&hThread, THREAD_ALL_ACCESS, NULL, NULL, NULL, (PKSTART_ROUTINE)MyUnloadRoutine, NULL);
}

void MyDeferredHandleDemotion(KDPC* Dpc, PVOID DeferredContext, PVOID SystemArgument1, PVOID SystemArgument2)
{
    DBG_LOG("My dpc runs! DeferredContext = %p", DeferredContext);
    
    // queue the work back down to passive level. (cant do shit with the handle table at dpc level)
    InterlockedIncrement(&HaveWorkToDo);

    InterlockedDecrement(&IAmBusyPleaseDoNotUnloadYet); // was incremented when we set the timer.
}

NTSTATUS PeriodicHandleScanThread(void* my_start_info)
{
    while (!IsUnloading)
    {
        LARGE_INTEGER interval;
        interval.QuadPart = -10000 * 5000; // every 1000ms
        KeDelayExecutionThread(KernelMode, FALSE, &interval);

        InterlockedIncrement(&HaveWorkToDo);
    }

    DBG_LOG("Handle stripping thread completes");

    InterlockedDecrement(&IAmBusyPleaseDoNotUnloadYet); // was incremented when we started the thread

    return STATUS_SUCCESS;
}

OB_PREOP_CALLBACK_STATUS MyObjPreCallback(
    _In_ PVOID                         RegistrationContext,
    _In_ POB_PRE_OPERATION_INFORMATION OperationInformation
)
{
    InterlockedIncrement(&IAmBusyPleaseDoNotUnloadYet);

    ACCESS_MASK* pDesiredAccess;
    PEPROCESS SourceProcess = IoGetCurrentProcess();
    char* OperationName;
    if (OperationInformation->Operation == OB_OPERATION_HANDLE_CREATE)
    {
        pDesiredAccess = &OperationInformation->Parameters->CreateHandleInformation.DesiredAccess;
        OperationName = "create";
    }
    else if (OperationInformation->Operation == OB_OPERATION_HANDLE_DUPLICATE)
    {
        pDesiredAccess = &OperationInformation->Parameters->DuplicateHandleInformation.DesiredAccess;
        OperationName = "duplicate";
    }
    else
    {
        DBG_LOG("Bad OperationInformation->Operation");
        DbgBreakPoint();
        InterlockedDecrement(&IAmBusyPleaseDoNotUnloadYet);
        return OB_PREOP_SUCCESS;
    }

    if (!OperationInformation->KernelHandle)
    {
        if (OperationInformation->ObjectType == *PsProcessType)
        {
            PEPROCESS ProcessInQuestion = OperationInformation->Object;

            char* SrcImageName = PsGetProcessImageFileName(SourceProcess);
            char* ProcessImageName = PsGetProcessImageFileName(ProcessInQuestion);

            if (strstr(ProcessImageName, "doskey.exe"))
            {
                // Allow user to unload the driver by running doskey.exe.
                DBG_LOG("  Unload requested");
                UnloadDriver();
            }
            else if (strstr(ProcessImageName, PROTECTED_PROCESS_NAME)
                || (OperationInformation->Operation == OB_OPERATION_HANDLE_DUPLICATE
                    && strstr(PsGetProcessImageFileName(OperationInformation->Parameters->DuplicateHandleInformation.SourceProcess), PROTECTED_PROCESS_NAME))
                )
            {
                DBG_LOG("%s tries to %s handle to %s, permissions %x", SrcImageName, OperationName, ProcessImageName, *pDesiredAccess);

                ULONG AllowOperation = 0;

                if ((*pDesiredAccess & ~(SYNCHRONIZE | PROCESS_TERMINATE)) == 0)
                {
                    DBG_LOG("  The requested handle is low access so we allow it");
                    AllowOperation = 1;
                }
                else if (IsProcessNameWhitelisted(SrcImageName))
                {
                    DBG_LOG("  Of course %s is allowed :)", SrcImageName);
                    AllowOperation = 1;
                }
                else if (!strcmp(SrcImageName, "csrss.exe") || !strcmp(SrcImageName, "lsass.exe"))
                {
                    DBG_LOG("  Ahh fuck it we let csrss do its job... peice of shit");
                    AllowOperation = 1;
                }
                else
                {
                    PEPROCESS CreatingProcess = LookupCreatingProcess(ProcessInQuestion);
                    if (CreatingProcess)
                    {
                        DBG_LOG("  This guy was created by pid %d %s", PsGetProcessId(CreatingProcess), PsGetProcessImageFileName(CreatingProcess));
                        if (CreatingProcess == SourceProcess)
                        {
                            BOOLEAN AllowParentHandleOperation = MyProcessInfoAllowOnce(ProcessInQuestion);
                            if (AllowParentHandleOperation)
                            {
                                // allow creating process to open handle to the protected process ... for now
                                DBG_LOG("  Ok, the parent is allowed for now");
                                // queue a deferred demotion for this handle later after createprocess does its job or whatever
                                LARGE_INTEGER interval = { .QuadPart = -10000 * 2500 }; // 2.5 seconds
                                BOOLEAN WasAlreadyQueued = KeSetTimer(&myTimer, interval, &myDpc);
                                if (!WasAlreadyQueued)
                                {
                                    // i consider this queue entry a ref on ourself.
                                    InterlockedIncrement(&IAmBusyPleaseDoNotUnloadYet);
                                }
                                *pDesiredAccess &= ~PROCESS_CREATE_THREAD; // wow!! no injection for u. bye
                                *pDesiredAccess &= ~PROCESS_CREATE_PROCESS; // block handle inheritance memes
                                //*pDesiredAccess &= ~PROCESS_DUP_HANDLE; // steam wants dup handle . but it doesnt seem to dup the csgo handle so ... idk
                                AllowOperation = 1;
                            }
                        }
                    }
                    else
                    {
                        DBG_LOG("  no process info tracked for %s????", ProcessImageName);
                    }
                }

                if (!AllowOperation)
                {
                    DBG_LOG("  You're not allowed so fuck off don't touch my process!!!");
                    *pDesiredAccess = SYNCHRONIZE | PROCESS_TERMINATE;
                }
            }
        }
        if (OperationInformation->ObjectType == *PsThreadType)
        {
            PETHREAD Thread = OperationInformation->Object;
            PEPROCESS Process = PsGetThreadProcess(Thread);
            char* ProcessImageName = PsGetProcessImageFileName(Process);
            char* SrcImageName = PsGetProcessImageFileName(SourceProcess);
            DBG_LOG("%s tries to touch thread in %s , operation type: %d", SrcImageName, ProcessImageName, OperationInformation->Operation);
            if (strstr(ProcessImageName, PROTECTED_PROCESS_NAME)) {
                DBG_LOG("  Don't fucking touch my protected process's thread asshole!!!");
                *pDesiredAccess = SYNCHRONIZE | THREAD_TERMINATE | THREAD_SUSPEND_RESUME;
            }
        }
    }

    InterlockedDecrement(&IAmBusyPleaseDoNotUnloadYet);
    return OB_PREOP_SUCCESS;
}

PUCHAR PatchLocationVirtual1;
PUCHAR PatchLocationVirtual2;

NTSTATUS SetupTrampolines()
{
    UNICODE_STRING driverName = RTL_CHONSTANT_STRING(L"\\Driver\\Null");

    NTSTATUS out = ObReferenceObjectByName(
        &driverName,
        OBJ_CASE_INSENSITIVE,
        NULL,
        0,
        IoDriverObjectType,
        KernelMode,
        NULL,
        (PVOID*)&pNullDriverObj);

    DBG_LOG("Null device object at %p. ntstatus code %x", pNullDriverObj, out);
    if (!pNullDriverObj)
    {
        DBG_LOG("ObReferenceObjectByName fails. Couldn't find null device?");
        return STATUS_UNSUCCESSFUL;
    }

    PVOID NullDevTextVirtual = (uintptr_t)pNullDriverObj->DriverStart + 0x1000; // we will use some empty space in .text for a trampoline

    // lock this page into memory

    nullDrvSectionHandle = MmLockPagableCodeSection(NullDevTextVirtual);
    DBG_LOG("nullDrvSectionHandle = %p", nullDrvSectionHandle);

    // Bypass MmVerifyCallbackFunctionCheckFlags by playing with some data structures

    PLDR_DATA_TABLE_ENTRY Entry = MiLookupDataTableEntry(NullDevTextVirtual, 0);

    if (!Entry)
    {
        DBG_LOG("Wtf? MiLookupDataTableEntry fails");
        return STATUS_UNSUCCESSFUL;
    }

    DBG_LOG("before flags %x", Entry->Flags);

    Entry->Flags |= PLDR_DATA_TABLE_ENTRY_Flags_Signed; // Bypass MmVerifyCallbackFunctionCheckFlags

    DBG_LOG("now flags %x", Entry->Flags);

    PHYSICAL_ADDRESS NullTextPhysical = MmGetPhysicalAddress(NullDevTextVirtual);

    // insert trampoline

    DBG_LOG("null device .text at physical %p", NullTextPhysical);

    PVOID MyMapping = MmMapIoSpace(NullTextPhysical, 0x1000, MmNonCached);
    if (!MyMapping)
    {
        DBG_LOG("WTF? MmMapIoSpace fails");
        return STATUS_UNSUCCESSFUL;
    }

    DBG_LOG("Mapped successfully :)");

    ASSERT(NULL_SYS_TEXT_SECTION_UNUSED_SPACE_OFFSET < 0x1000);
    ULONGLONG TrampolineOffset1 = NULL_SYS_TEXT_SECTION_UNUSED_SPACE_OFFSET; // some unused space in .text we can jam our trampoline
    ULONGLONG TrampolineOffset2 = TrampolineOffset1 + sizeof(Trampoline); // some unused space in .text we can jam our trampoline

    PUCHAR PatchLocation1 = (uintptr_t)MyMapping + TrampolineOffset1;
    *(DWORD64*)(Trampoline + 2) = (DWORD64)MyObjPreCallback;
    memcpy(PatchLocation1, Trampoline, sizeof(Trampoline));

    PUCHAR PatchLocation2 = (uintptr_t)MyMapping + TrampolineOffset2;
    *(DWORD64*)(Trampoline + 2) = (DWORD64)MyCreateProcessNotifyRoutine;
    memcpy(PatchLocation2, Trampoline, sizeof(Trampoline));

    DBG_LOG("Patches applied");

    PatchLocationVirtual1 = (uintptr_t)NullDevTextVirtual + TrampolineOffset1;
    PatchLocationVirtual2 = (uintptr_t)NullDevTextVirtual + TrampolineOffset2;

    MmUnmapIoSpace(MyMapping, 0x1000);

    DBG_LOG("Unmapped successfully :)");

    return STATUS_SUCCESS;
}

NTSTATUS DriverEntry(
    MyIrpStruct* my_start_info
    )
{
    DBG_LOG("THIS IS FROM MY MANAUAL MAPPED DRIVER!!!!!!!!!!!1");
    DBG_LOG("Driver base = %p", my_start_info->MappedDriverBase);

    DBG_LOG("MiLookupDataTableEntry at %p", MiLookupDataTableEntry);

    InitializeMyProcessInfoList();

    KeInitializeDpc(&myDpc, MyDeferredHandleDemotion, NULL);
    KeInitializeTimer(&myTimer);

    if (SetupTrampolines() != STATUS_SUCCESS)
    {
        DBG_LOG("failed to setup trampolines in null.sys");
        return STATUS_UNSUCCESSFUL;
    }

    PVOID MyObjPreCallback_Trampoline = PatchLocationVirtual1;
    PVOID MyCreateProcessNotifyRoutine_Trampoline = PatchLocationVirtual2;
    MyCreateProcessNotifyRoutine_Handle = MyCreateProcessNotifyRoutine_Trampoline;

    UNICODE_STRING MyAltitude;
    RtlInitUnicodeString(&MyAltitude, L"123456");

    OB_OPERATION_REGISTRATION MyOperationRegistration[1];
    MyOperationRegistration[0].ObjectType = PsProcessType;
    MyOperationRegistration[0].Operations = OB_OPERATION_HANDLE_CREATE | OB_OPERATION_HANDLE_DUPLICATE;
    MyOperationRegistration[0].PreOperation = MyObjPreCallback_Trampoline;
    MyOperationRegistration[0].PostOperation = NULL;

    OB_CALLBACK_REGISTRATION MyObCallbackInfo;
    MyObCallbackInfo.Version = OB_FLT_REGISTRATION_VERSION;
    MyObCallbackInfo.OperationRegistrationCount = 1;
    MyObCallbackInfo.Altitude = MyAltitude;
    MyObCallbackInfo.RegistrationContext = &MyRegistrationContext;
    MyObCallbackInfo.OperationRegistration = MyOperationRegistration;


    InterlockedIncrement(&IAmBusyPleaseDoNotUnloadYet); // i consider this callback entry a "ref".
    NTSTATUS Result = ObRegisterCallbacks(&MyObCallbackInfo, &MyRegistrationHandle);
    DBG_LOG("ObRegisterCallbacks returns %x", Result);
    if (Result != STATUS_SUCCESS)
    {
        DBG_LOG("ObRegisterCallbacks failed! :(");
        return Result;
    }

    InterlockedIncrement(&IAmBusyPleaseDoNotUnloadYet); // i consider this callback entry a "ref".
    Result = PsSetCreateProcessNotifyRoutineEx(MyCreateProcessNotifyRoutine_Trampoline, FALSE);
    DBG_LOG("PsSetCreateProcessNotifyRoutineEx returns %x", Result);
    if (Result != STATUS_SUCCESS)
    {
        DBG_LOG("PsSetCreateProcessNotifyRoutineEx failed! :(");
        return Result;
    }

    InterlockedIncrement(&IAmBusyPleaseDoNotUnloadYet); // take a ref on ourself when we create the thread.
    HANDLE hThread;
    Result = PsCreateSystemThread(&hThread, THREAD_ALL_ACCESS, NULL, NULL, NULL, (PKSTART_ROUTINE)StripHandleThread, NULL);
    DBG_LOG("PsCreateSystemThread returns %x", Result);
    ZwClose(hThread);

    InterlockedIncrement(&IAmBusyPleaseDoNotUnloadYet); // take a ref on ourself when we create the thread.
    Result = PsCreateSystemThread(&hThread, THREAD_ALL_ACCESS, NULL, NULL, NULL, (PKSTART_ROUTINE)PeriodicHandleScanThread, NULL);
    DBG_LOG("PsCreateSystemThread returns %x", Result);
    ZwClose(hThread);

    return STATUS_SUCCESS;
}
